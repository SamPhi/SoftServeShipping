#include <Arduino.h>
#include <ESP32Encoder.h>

///REQUIRED ADDITIONAL IMPORTS

/// END IMPORTS

//Code from other scripts:

ESP32Encoder encoder1;
int enc_core1;

int LS1=4;
int LS2=16;
//END

//MOTOR SETUP
const int BIN_1 = 25;
const int BIN_2 = 26;
//setting PWM properties ----------------------------
const int freq = 25000;
const int ledChannel_1 = 1;
const int ledChannel_2 = 2;
const int resolution = 8;
const int enc_core1 = 0;
//END MOTOR SETUP

//Physical parameters:
const int g = 9.81;
const int zeroPos = 0
const int last_x_pos = 0
const int massGantry = 0.5 //Kg
const int massContainer = 0.1 //Kg
const int lengthCable = 0.25 //m
const int g = 9.81 //m/s^2
const int dt = 0.001
const int lastTheta = 0

void setup() {
  //encoder
  Serial.begin(115200);
  ESP32Encoder::useInternalWeakPullResistors = UP; // Enable the weak pull up resistors
  encoder1.attachHalfQuad(39, 36); // Attache pins for use as encoder pins  M1(36,39)   M2(4,16)   M3(17,21)
  encoder1.setCount(0);  // set starting count value after attaching
  
  //Lim switches from other script:
  pinMode(LS1, INPUT_PULLUP);
  pinMode(LS2, INPUT_PULLUP);
  //

  // MOTOR SETUP
  // configure LED PWM functionalitites
  ledcSetup(ledChannel_1, freq, resolution);
  ledcSetup(ledChannel_2, freq, resolution);
  // attach the channel to the GPIO to be controlled
  ledcAttachPin(BIN_1, ledChannel_1);
  ledcAttachPin(BIN_2, ledChannel_2);

  //END MOTOR SETUP

  Serial.begin(9600);
  //pinMode(startSensor, INPUT_PULLUP);
  //pinMode(endSensor, INPUT_PULLUP);
}

void writeMotors(int PWM){ 
  //Check PWM Limits
  if (PWM>1023) {
    PWM = 1023;
  }
  if (PWM<-1023) {
    PWM = -1023;
  }

  //Set motor PWM based on sign, and check not hitting relevant limit switch for given direction
  if ((PWM >= 0) && !checkLimRight()) {
    ledcWrite(ledChannel_1, LOW);
    ledcWrite(ledChannel_2, PWM);
  }
  else if ((PWM < 0) && !checkLimLeft()){
    ledcWrite(ledChannel_1, -PWM);
    ledcWrite(ledChannel_2, LOW);
  }
  else {
    ledcWrite(ledChannel_1, LOW);
    ledcWrite(ledChannel_2, LOW);
  }
}


//Code from other scripts:
bool checkLimLeft() {
  if (digitalRead(LS1) == LOW) {
    return true;}
  else {return false;}
}

bool checkLimRight() {
  if (digitalRead(LS2) == LOW) {
    return true;}
  else {return false;}
}

int auto_u_container(dth,g,l,m1,m2,t,th,x,x_des) {
    //AUTO_U_CONTAINER
    //    U = AUTO_U_CONTAINER(DTH,G,L,M1,M2,T,TH,X,X_DES)

    //    This function was generated by the Symbolic Math Toolbox version 9.2.
    //    25-Apr-2023 12:37:52

    t2 = cos(th);
    t3 = sin(th);
    t4 = t2^2;
    u = -(l*(m1+m2-m2*t4)*(dth*(-1.0/2.0)-th*3.0e+1+x*(3.0/2.0)-x_des*(3.0/2.0)+((x/10-x_des/10+8.630374447253786*10^(-4))*3.0e+1)/(t-10)+(g*t3*(m1+m2))/(l*(m1+m2*t3^2))+(dth^2*m2*t2*t3*2.0)/(m1*2.0+m2-m2*(t4*2.0-1.0))))/t2;
    return u
}

void autoMove(self, x_des) {
    if x_des == 0:
        x_des = 500 //TODO: Remove me after testing!!!
        
    //define state vars
    th = self.getTheta()*math.pi/180
    g = g
    l = lengthCable
    mg = massGantry #Kg
    mc = massContainer #Kg
    t = dt
    th_past = lastTheta
    dth = (th_past - th)/dt
    x = encoder1.getCount()
    
    cout << "X pos " << x

    u = auto_u_container(dth,g,l,mg,mc,t,th,x,x_des)
    
    cout << "u = " << u
    
    PWM = u //TODO turn this into real value

    //Actually write calculated PWMN vals to motor
    //self.writeMotors(PWM)

    //Update past values for next run
    self.last_x_pos = x
    self.lastTheta = theta
    return
}

void loop() {
  enc_core1 = encoder1.getCount();
  writeMotors(-250);
}
